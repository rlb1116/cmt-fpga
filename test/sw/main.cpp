// Copyright (c) 2020 University of Florida
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

// Greg Stitt
// University of Florida
//
// Description: This application demonstrates a simple AFU pipeline that 
// streams 32-bit unsigned integers from an input array into the AFU. The AFU 
// multiplies 8 pairs of inputs (from a single cache line), accumulates the 
// results, and writes a 64-bit result to an output array. Because a full 
// cache line must be written to memory with the provided DMA, the application 
// takes as input the number of output cache lines, and then determines the 
// appropriate number of outputs and inputs to fill those cache lines. 
//
// This software allocates the input and output arrays, initializes their 
// contents, transfers the virtual addresses of the arrays, the 
// number of input cache lines to read, and a go signal to start the AFU. The
// software then waits until the AFU signals that it is done.

#include <cstdlib>
#include <iostream>
#include <cmath>
#include <cfloat>

#include <algorithm>	// std::copy

#include <chrono>	// high_resolution_clock 

#include <opae/utils.h>

#include "AFU.h"
// Contains application-specific information
#include "config.h"
// Auto-generated by OPAE's afu_json_mgr script
#include "afu_json_info.h"

using namespace std;

#define ELEMENT_SIZE 8
#define DMAX 1024.0
#define DMIN -1023.0

void printUsage(char *name);
bool checkUsage(int argc, char *argv[], unsigned long &num_inputs);
uint64_t getCorrectOutput(volatile uint32_t input[], unsigned output_id);
double dRand(double dMin, double dMax);
bool equalDouble(double a, double b);
void getSWoutputDtDsDr(int N, double kernel[], double input[], double output[]);

int main(int argc, char *argv[]) {

  unsigned long num_output_cls;
  unsigned long num_inputs;
  unsigned long num_outputs;

//  unsigned int element_size = 8;	// ~5-32
  unsigned int kernel_size;	// N^2
  unsigned int data_in_size;	// N^3

//  if (!checkUsage(argc, argv, num_output_cls)) {
//    printUsage(argv[0]);
//    return EXIT_FAILURE;
//  }
  
  // There are 8 64-bit outputs per cache line.
//  num_outputs = num_output_cls * 8;
  num_outputs = 3 * ELEMENT_SIZE * ELEMENT_SIZE * ELEMENT_SIZE;		// 3 * N^3
  // There are 16 32-bit inputs per output.
//  num_inputn = num_outputs * 16;
  kernel_size = (ELEMENT_SIZE * ELEMENT_SIZE);
  data_in_size = (ELEMENT_SIZE * ELEMENT_SIZE * ELEMENT_SIZE);
  num_inputs = kernel_size + data_in_size;	// N^2 + N^3

  try {
    AFU afu(AFU_ACCEL_UUID); 
    bool failed = false;

    // Allocate input and output arrays.
    auto input  = afu.malloc<volatile double>(num_inputs);
    auto output = afu.malloc<volatile double>(num_outputs);  

    double kernel_data [kernel_size];
    double data_in [data_in_size];
    double sw_output [num_outputs];

    // Initialize the input and output arrays.
    for (unsigned i=0; i < kernel_size; i++) {
      kernel_data[i] = dRand(DMIN, DMAX);
      input[i] = kernel_data[i];	// copy to combined input structure
    }

    for (unsigned i=0; i < data_in_size; i++) {
      data_in[i] = dRand(DMIN, DMAX);
      input[i + kernel_size] = data_in[i];	// copy to combined input structure
    }

    for (unsigned i=0; i < num_outputs; i++) {      
      output[i] = 0.0;
      sw_output[i] = 0.0;
    }   
   
    cout << "Sending memory locations to FPGA." << endl; 
    auto mm_start = chrono::high_resolution_clock::now();       // MMIO start time
    // Inform the FPGA of the starting addresses of the arrays.
    afu.write(MMIO_RD_ADDR, (uint64_t) input);
    afu.write(MMIO_WR_ADDR, (uint64_t) output);

    // The FPGA DMA only handles cache-line transfers, so we need to convert
    // the input array size to cache lines. We could also do this conversion 
    // on the FPGA and transfer the number of inputs instead here.
    // Same calculation for number of output cache lines.
    unsigned total_bytes_in = num_inputs*sizeof(double);
    unsigned num_cls_in = ceil((float) total_bytes_in / (float) AFU::CL_BYTES);
    unsigned total_bytes_out = num_outputs*sizeof(double);
    unsigned num_cls_out = ceil((float) total_bytes_out / (float) AFU::CL_BYTES);

//    cout << "Sending array dimensions; FPGA will calculate total size." << endl;
    afu.write(MMIO_IN_SIZE, num_cls_in);
    afu.write(MMIO_OUT_SIZE, num_cls_out);

//    cout << "Sending GO signal to FPGA." << endl;

    // Start the FPGA DMA transfer (cleared automatically by the AFU).
    afu.write(MMIO_GO, 1);
    auto mm_end = chrono::high_resolution_clock::now();       // MMIO end time  
    auto hw_start = chrono::high_resolution_clock::now();       // FPGA start time

//    cout << "Waiting for DONE signal from FPGA." << endl;
    // Wait until the FPGA is done.
    while (afu.read(MMIO_DONE) == 0) {
#ifdef SLEEP_WHILE_WAITING
      this_thread::sleep_for(chrono::milliseconds(SLEEP_MS));
#endif
    }
    auto hw_end = chrono::high_resolution_clock::now();	// FPGA end time

    cout << "FPGA done. Verifying results in CPU." << endl;
    // Get same output calculated by software
    auto sw_start = chrono::high_resolution_clock::now();	// CPU start time
    getSWoutputDtDsDr(ELEMENT_SIZE, kernel_data, data_in, sw_output);
    auto sw_end = chrono::high_resolution_clock::now();		// CPU end time

    double hw_time = chrono::duration_cast<chrono::nanoseconds>(hw_end - hw_start).count();	// nanoseconds
    double sw_time = chrono::duration_cast<chrono::nanoseconds>(sw_end - sw_start).count();
    double mm_time = chrono::duration_cast<chrono::nanoseconds>(mm_end - mm_start).count();

    cout << "MMIO overhead time:    " << mm_time << " ns." << endl;
    cout << "FPGA calculation time: " << hw_time << " ns." << endl;
    cout << "CPU calculation time:  " << sw_time << " ns." << endl;

    // Verify the output.
    unsigned errors = 0;
    for (unsigned i=0; i < num_outputs; i++) {     
      if (!equalDouble((double)output[i], sw_output[i])) {
	errors ++;
        cout << "ERROR: output "<< i <<" - FPGA val="<< output[i] <<", CPU val="<< sw_output[i] <<", difference="<< (output[i] - sw_output[i]) << endl;
      }
    }

    // Free the allocated memory.
    afu.free(input);
    afu.free(output);
        
    if (errors == 0) {
      cout << "SUCCESS: all outputs correct." << endl;
      return EXIT_SUCCESS;
    }
    
    cout << "FAILURE: " << errors << " / " << num_outputs << " incorrect outputs." << endl;
  }
  // Exception handling for all the runtime errors that can occur within 
  // the AFU wrapper class.
  catch (const fpga_result& e) {    
    
    // Provide more meaningful error messages for each exception.
    if (e == FPGA_BUSY) {
      cerr << "ERROR: All FPGAs busy." << endl;
    }
    else if (e == FPGA_NOT_FOUND) { 
      cerr << "ERROR: FPGA with accelerator " << AFU_ACCEL_UUID 
	   << " not found." << endl;
    }
    else {
      // Print the default error string for the remaining fpga_result types.
      cerr << "ERROR: " << fpgaErrStr(e) << endl;    
    }
  }
  catch (const runtime_error& e) {    
    cerr << e.what() << endl;
  }
  catch (const opae::fpga::types::no_driver& e) {
    cerr << "ERROR: No FPGA driver found." << endl;
  }

  return EXIT_FAILURE;
}


void printUsage(char *name) {

  cout << "Usage: " << name << " size\n"     
       << "size (positive integer for number of output cache lines to test. Every output cache line adds 8 32-bit outputs and 128 64-bit inputs.)\n"
       << endl;
}

// Returns unsigned long representation of string str.
// Throws an exception if str is not a positive integer.
unsigned long stringToPositiveInt(char *str) {

  char *p;
  long num = strtol(str, &p, 10);  
  if (p != 0 && *p == '\0' && num > 0) {
    return num;
  }

  throw runtime_error("String is not a positive integer.");
  return 0;  
}


bool checkUsage(int argc, char *argv[], unsigned long &num_output_cls) {
  
  if (argc == 2) {
    try {
      num_output_cls = stringToPositiveInt(argv[1]);
    }
    catch (const runtime_error& e) {    
      return false;
    }
  }
  else {
    return false;
  }

  return true;
}


uint64_t getCorrectOutput(volatile uint32_t input[], unsigned output_id) {

  // There are 16 inputs for every output, so find the appropriate range
  // of the input array to calculate the requested output.
  unsigned start_index = output_id*16;
  unsigned end_index = start_index + 16;

  // Perform the same computation as the AFU pipeline.
  uint64_t result = 0;
  for (unsigned i=start_index; i < end_index; i+=2) {
    result += (uint64_t) input[i] * (uint64_t) input[i+1];
  }

  return result;
}

bool equalDouble(double a, double b) {
  double relTol = 0.00001;
  double absTol = 10*DBL_MIN;
  return (abs(a - b) < fmax(absTol, relTol * fmax(abs(a), abs(b))));
}

double dRand(double dMin, double dMax) {
  double d = (double)rand() / RAND_MAX;
  return dMin + d * (dMax - dMin);
}

void getSWoutputDtDsDr(int N, double kernel[], double input[], double output[]) {
  
  // Kernel size: N*N; Input size: N*N*N; Output size: 3*N*N*N
  // Calculate dt, then ds, then dr to mimic FPGA order of results
  // Store dt->output[0..N*N*N-1], ds->output[N*N*N..2*N*N*N-1], dr->output[2*N*N*N..3*N*N*N-1]
  //
  
  int N2 = N*N;
  int N3 = N*N*N;
  int i,j,k,g;
  int iN2, jN, kN, iN;

  for (i = 0; i < N; i++) {
    iN2 = i*N2;
    for (j = 0; j < N; j++) {
      jN = j*N;
      for (k = 0; k < N; k++) {
        kN = k*N;
        for (g = 0; g < N; g++) {
          // dt
          output[iN2 + jN + k] += kernel[kN + g] * input[iN2 + jN + g];
        }
      }
    }
  }

  for (i = 0; i < N; i++) {
    iN2 = i*N2;
    for (j = 0; j < N; j++) {
      jN = j*N;
      for (k = 0; k < N; k++) {
        for (g = 0; g < N; g++) {
          // ds
          output[N3 + iN2 + jN + k] += kernel[jN + g] * input[iN2 + g*N + k];
        }
      }
    }
  }
          
  for (i = 0; i < N; i++) {
    iN2 = i*N2;
    iN = i*N;
    for (j = 0; j < N; j++) {
      jN = j*N;
      for (k = 0; k < N; k++) {
        for (g = 0; g < N; g++) {
          // dr
          output[2*N3 + iN2 + jN + k] += kernel[iN + g] * input[g*N2 + jN + k];
        }
      }
    }
  }
      
}
